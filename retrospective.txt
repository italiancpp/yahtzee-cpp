Spunti per le retrospective:

[PRODUTTIVITA']

- ci sono un po' auto tolti in giro

- range-based for loop

	for (size_t i = 0u; i < dice.size(); ++i)
	{
		dice[i].value = rdist(rengine);
	}

diventa:

	for (auto& die : dice)
	{
		if (false == die.hold)
			die.value = rdist(rengine);
	}

Se teniamo questo operator<< il cambio è d'impatto:

ostream& operator<<(ostream& stream, const ScoreTable& table) 
{
	for (map<std::string, Score>::const_iterator it = table.scores.begin(); it != table.scores.end(); ++it)
		stream << it->first << " -> " << it->second.value << (it->second.assigned ? "" : " *") << endl;
	
diventa:	

	for (const auto& score : table.scores)
	{
		stream << score.first << " -> " << score.second.value << (score.second.assigned ? "" : " *") << endl;
	}
	
	return stream;
}

[OWNERSHIP]

- containers

unsigned short* ranks = new unsigned short[maxDiceValue];
CalculateRanks(dice, ranks);

invece di:

auto ranks = CalculateRanks(dice, maxDiceValue);

- l'esempio sopra è anche un modo per spiegare la move-semantics

- memory management --> primo refactoring da cascata di if a regole con unique_ptr

- Rule of Zero --> ci sono alcune classi (ScoreCalculator e ScoreTable) con distruttore/copy inutili

[ALGORITMI]

- ScoreTable::TotalScore può usare accumulate

- da trovare almeno un altro caso con statistiche

- mostrare le lambdas (per esempio per le regole)

[TEMPLATE/GENERIC PROGRAMMING]